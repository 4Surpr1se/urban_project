Вам необходимо будет релизовать алгоритм работы lru cache:

LRU (Least Recently Used) Cache - это алгоритм, при котором вытесняются значения, которые дольше всего не
запрашивались. Таким образом, lru cache - это словарь из пар ключ - значение, который при получении значения (метод get)
или
записи нового (метод put), становится в начало очереди. Та пара, что была на первом месте, переходит на вторую позицию
очереди,
вторая на третью и т.д.
Если последний элемент находится за границами кэша (capacity), то он из кэша удаляется.
В Вашей реализации класс LRUCache должен принимать переменную capacity - максимальный размер кэша
и должно быть реализованно два метода get (возвращает значение по ключу, если оно есть в кэше, при его отсутствии
возвращает -1)
и put (принимает ключ и значение, записывает под этим ключом значение в кэш, если ключ уже есть в кэше,
перезаписывает его):

   ```py
   class LRUCache:

    def __init__(self, capacity):
        ...

    def get(self, key):
        ...

    def put(self, key, value):
        ...
   ```

**Пример**:
lru_cache = LRUCache(2)
lru_cache.put(1, 1) # кэш: {1:1}
lru_cache.put(2, 2) # кэш: {1:1, 2:2}
lru_cache.get(1) # возвращает 1
lru_cache.put(3, 3) # удаляет последнюю пару, чтобы 3:3 поместилось в кэш, это пара 2:2, кэш: {1:1, 3:3}
lru_cache.get(2) # возвращает -1 (отсутствует)
lru_cache.put(4, 4) # удаляет последнюю пару, чтобы 4:4 поместилось в кэш, это пара 1:1, кэш: {4:4, 3:3}
lru_cache.get(1) # возвращает -1 (отсутствует)
lru_cache.get(3) # возвращает 3
lru_cache.get(4) # возвращает 4

**Важно**: Ваше решение должно содержать только реализацию класса, работу с классами, как в примере реализовывать не
надо.

**Подсказка**: Здесь Вам могут понадобиться двусвязные списки