_1_algorithm

Вам необходимо будет релизовать алгоритм работы lru cache:

LRU (Least Recently Used) Cache - это алгоритм, при котором вытесняются значения, которые дольше всего не
запрашивались. Таким образом, lru cache - это словарь из пар ключ - значение, который при получении значения (метод get)
или
записи нового (метод put), становится в начало очереди. Та пара, что была на первом месте, переходит на вторую позицию
очереди,
вторая на третью и т.д.
Если последний элемент находится за границами кэша (capacity), то он из кэша удаляется.
В Вашей реализации класс LRUCache должен принимать переменную capacity - максимальный размер кэша
и должно быть реализованно два метода get (возвращает значение по ключу, если оно есть в кэше, при его отсутствии
возвращает -1)
и put (принимает ключ и значение, записывает под этим ключом значение в кэш, если ключ уже есть в кэше,
перезаписывает его):

   ```py
   class LRUCache:

    def __init__(self, capacity):
        ...

    def get(self, key):
        ...

    def put(self, key, value):
        ...
   ```

**Пример**:
lru_cache = LRUCache(2)
lru_cache.put(1, 1) # кэш: {1:1}
lru_cache.put(2, 2) # кэш: {1:1, 2:2}
lru_cache.get(1) # возвращает 1
lru_cache.put(3, 3) # удаляет последнюю пару, чтобы 3:3 поместилось в кэш, это пара 2:2, кэш: {1:1, 3:3}
lru_cache.get(2) # возвращает -1 (отсутствует)
lru_cache.put(4, 4) # удаляет последнюю пару, чтобы 4:4 поместилось в кэш, это пара 1:1, кэш: {4:4, 3:3}
lru_cache.get(1) # возвращает -1 (отсутствует)
lru_cache.get(3) # возвращает 3
lru_cache.get(4) # возвращает 4

**Важно**: Ваше решение должно содержать только реализацию класса, работу с классами, как в примере реализовывать не
надо.

**Подсказка**: Здесь Вам могут понадобиться двусвязные списки

_2_decorator

Вам необходимо будет реализовать декоратор ```lru_cache``` на основе алгоритма из предыдущего проекта,
который будет запоминать результат работы функции исходя из аргументов. Ваш декоратор должен принимать аргументом
размер кэша ```capacity```.

**Подсказка**: Здесь Вам может понадобиться декоратор ```wraps``` из модуля ```functools```

_3_annotations

Следующие проверки Вам нужно будет соблюдать в рамках всех последующих проектов.

Добавьте их для текущего проекта.
- Установите poetry для вашего проекта и перенесите туда все зависимости.
- Добавьте и проверьте типизацию любым удобным анализатор типов, например, mypy.
- Проверьте Ваш проект на стандарты кодирования с помощью линтера, например, flake8.

_4_async_project

Вам нужно будет реализовать CRUD операции на FastAPI для User'ов с помощью Вашей ORM:
- GET /users/ - методов select, возвращающий всех пользователей
- POST /users/ - метод insert, создание пользователя
- PUT /users/<id:int> - метод update_by_id, обновление пользователя по id
- DELETE /users/ - метод delete_by_id, удаление пользователя по id

Структуру советуем использовать следующую:
![img.png](img.png)

_6_graphql_task

Вам предстоит реализовать стриминг ```GraphQL``` сервис на основе транспортного протокола ```WebSocket```, для этого Вам
нужно будет реализовать эндпоинт ```/graphql```
с подпиской, которая будет принимать uuid фильма и секунду фильма:
```subscription { stream(film_id:<film_id:uuid>, film_second: <film_second>) }``` и внутри websocket соединения
передавать фрагменты фильма ```film_id```, сериализованные в байты, начиная с ```film_second``` до тех пор пока не
закроется соединение. Для этого Вам может понадобится библиотека ```strawberry```, а для тестирования Вашего сервиса
библиотека ```websocket```, так же не забывайте при тестировании указывать аргумент subprotocol:

```py
import websockets

uri = "ws://localhost:8000/graphql"
async with websockets.connect(uri, subprotocols=["graphql-ws"]) as websocket:
    ...
```

В финале все Ваши мини-проекты соберутся в один стриминг сервис фильмов, фронт мы берем на себя :)

_7_grpc

Вам нужно будет реализовать
Cервис аутентификации на основе нашей ОРМ, структура базы данных должна быть следующей:

erDiagram
USERS ||--o{ USER_ROLES : has
USERS ||--o{ LOGIN_HISTORY : has
ROLES ||--o{ USER_ROLES : has
ROLES ||--o{ ROLE_PERMISSIONS : has
PERMISSIONS ||--o{ ROLE_PERMISSIONS : has

    USERS {
        uuid id PK
        string username
        string email
        string hashed_password
        boolean is_active
        timestamp created_at
        timestamp updated_at
    }

    ROLES {
        uuid id PK
        string name
        string description
        timestamp created_at
        timestamp updated_at
    }

    PERMISSIONS {
        uuid id PK
        string name
        string description
        timestamp created_at
        timestamp updated_at
    }

    USER_ROLES {
        uuid user_id FK
        uuid role_id FK
    }

    ROLE_PERMISSIONS {
        uuid role_id FK
        uuid permission_id FK
    }

    LOGIN_HISTORY {
        uuid id PK
        uuid user_id FK
        string ip_address
        string user_agent
        timestamp login_at
    }

Релизовать сервис нужно будет на основе протокола grpc (для этого рекомендуем
использовать [fast-grpc](https://github.com/OlegYurchik/fast-grpc)),
а аутентификация с использованием jwt.
Однако структура не должна быть привязана к транспортному протоколу и способу аутентификации,
за структурную основу можете взять Ваш `FASTAPI` cервис с реализацией орм, единственное, нужно будет добавить прослойку
аутентификации и авторизации, так же добавить интерфейс работы с пермишенами и ролями, в будущем Ваше стриминг
приложение будет обращаться к этому сервису для проверки пользователя.

